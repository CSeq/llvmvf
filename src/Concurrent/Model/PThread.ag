optpragmas {
{-#LANGUAGE EmptyDataDecls, RecordWildCards #-}
}

{
-------------------------------------------------------------------------------
-- Module    :  Concurrent.Model.PThread
-- Copyright :  (c) 2012 Marcelo Sousa
-------------------------------------------------------------------------------
}

module {Concurrent.Model.PThread}{}{}

include "Base.ag"
include "Type.ag"

imports 
{
import qualified Data.Map as Map
import qualified Data.IntMap as IM
import Data.Maybe 

import Concurrent.Model
import Language.LLVMIR
import UU.PPrint

import Debug.Trace (trace)
}

attr Module 
  syn pmdl :: {Model PThread}

sem Module
  | Module lhs.pmdl  = Model @nmdtys.self @gvars.self @funs.mainf @funs.pmdl @funs.decls
           funs.mfun = @funs.self
           funs.counter = 1

attr Functions
  syn mainf :: {Process}
  
attr Functions Function BasicBlocks BasicBlock Instructions Instruction
  syn pmdl  use {`IM.union`} {IM.empty} :: {IM.IntMap Process}
  syn decls use {`Map.union`} {Map.empty} :: {Map.Map String (Type,Parameters)}
  inh mfun      :: {Map.Map String Function}
  chn counter   :: {ThreadLabel}
  
attr Function BasicBlocks BasicBlock Instructions Instruction Value Identifier Constant ConstantFP Linkage CConv Visibility DefinitionTy Argument Align GCName FunAttr Attribute Section TargetData Target Parameter IntPredicate RealPredicate GlobalValue ConstantDataSequential ConstantExpr SimpleConstant ComplexConstant RetInst NamedTypes CompareConstantExpr BinOp AtomicOrdering Type Types Parameters TyFloatPoint Arguments Values Id ValIdL ValId PValues MIdentifier PValue Ints PC 
  syn annotated :: self 

sem Functions
  | Nil   lhs.pmdl = IM.empty
          lhs.mainf = error "No Main Function"
  | Entry lhs.pmdl = if @key == "main"
                     then @val.pmdl 
                     else @tl.pmdl
          lhs.mainf = if @key == "main"
                      then (Process @key @val.annotated)
                      else @tl.mainf

sem Function
  | FunctionDef  lhs.pmdl = @body.pmdl
                 lhs.decls = Map.singleton (getIdName @name.self) (@retty.self, @params.self)
  | FunctionDecl lhs.pmdl = IM.empty 
                    +decls = Map.union (Map.singleton (getIdName @name.self) (@retty.self, @params.self))

sem BasicBlock
  | BasicBlock lhs.pmdl = @instrs.pmdl

sem Instruction
  | Call 
    +pmdl = IM.union (snd @loc.proc)
    lhs.annotated = case @loc.calleename of
                         "pthread_create"       -> CreateThread @pc.self @args.self
                         "pthread_mutex_init"   -> MutexInit    @pc.self @mres.self (@args.self !! 0)
                         "pthread_mutex_lock"   -> MutexLock    @pc.self @mres.self (@args.self !! 0)
                         "pthread_mutex_unlock" -> MutexUnlock  @pc.self @mres.self (@args.self !! 0)
                         x                      -> Call         @pc.self @mres.self @ty.self @callee.self @args.self   
    loc.proc = buildProcess @loc.counter @loc.calleename @args.self @lhs.mfun
    loc.calleename = getIdName @callee.self
    loc.counter :: uniqueref counter

{
type ThreadLabel = Int

nextUnique :: Int -> (Int, Int)
nextUnique u = (u+1, u)

getIdName :: Identifier -> String
getIdName (Global n) = n
getIdName (Local  n) = n

buildProcess :: Int -> String -> Values -> Map.Map String Function -> (Bool, IM.IntMap Process)
buildProcess c "pthread_create" v m = case v !! 2 of
                                        Constant (GlobalValue (FunctionValue i _)) -> let vn = getIdName i
                                                                                          f  = fromMaybe (error "buildProcess 1") $ Map.lookup vn m
                                                                                          f' = annotated_Syn_Function $ wrap_Function (sem_Function f) $ Inh_Function { counter_Inh_Function = undefined, mfun_Inh_Function = undefined }
                                                                                      in (True, IM.singleton c $ Process vn f')
                                        _ -> error "buildProcess 2"  
buildProcess c _                _ _ = (False, IM.empty)
 
-- PThread
data PThread

-- Synchronous (Interleaved) Concurrent Models
-- At one given time, there only one atomic instruction
-- being executed. Scheduler specification is required.
instance SCModel PThread where
  -- model :: Module -> Model PThread
  model mdl = pmdl_Syn_Module $ wrap_Module (sem_Module mdl) $ Inh_Module {}

instance Pretty PThread 
}
