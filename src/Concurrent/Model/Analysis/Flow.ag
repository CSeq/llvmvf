{
-------------------------------------------------------------------------------
-- Module    :  Concurrent.Model.Analysis.Flow
-- Copyright :  (c) 2012 Marcelo Sousa
-------------------------------------------------------------------------------
}

module {Concurrent.Model.Analysis.Flow}{}{}

include "Base.ag"

imports{
import qualified Data.Map as Map
import qualified Data.IntMap as IM
import Data.Maybe 

import Debug.Trace

import Language.LLVMIR
}

-- Concurrent Control Flow Graph
attr Function BasicBlocks BasicBlock Instructions Instruction
  chn cpc :: {Int}

attr Functions
  inh bbentrypci :: {Map.Map String (Map.Map String Int)}
  syn flow use {++} {[]} :: {Flow}
 
attr Function BasicBlocks BasicBlock Instructions Instruction
  syn flow use {++} {[]} :: {Flow}
  inh bbentrypci :: {Map.Map String Int}

sem Functions
  | Entry
      lhs.flow = @loc.cflow ++ @val.flow ++ @tl.flow
      val.cpc  = @val.entrypc
      val.bbentrypci = fromMaybe (error "lookup") (Map.lookup @key @lhs.bbentrypci)
      loc.cflow = if @key /= "main"
                  then [(-1,@val.entrypc)]
                  else []
sem Function
  | FunctionDef
      lhs.flow = @body.flow
 
sem BasicBlock
  | BasicBlock
      lhs.flow = tail @instrs.flow

sem Instruction
  | Ret Alloca Load Store ICmp FCmp Call Unreachable Trunc ZExt SExt FPToUI FPToSI UIToFP SIToFP FPTrunc FPExt PtrToInt IntToPtr BitCast GetElementPtr Add FAdd Sub FSub Mul FMul UDiv SDiv FDiv URem SRem FRem Shl LShr AShr And Or Xor PHI Select ExtractValue AtomicRMW
      +flow = (++) [(@lhs.cpc, @pc.self)]
      lhs.cpc = @pc.self
  | CreateThread 
      +flow = (++) [(@lhs.cpc, @pc.self), (@pc.self, -1)] 
      lhs.cpc = @pc.self
  | UBr 
      +flow = (++) [(@lhs.cpc, @pc.self), (@pc.self, getEntry (getId @d.self) @lhs.bbentrypci)]
      lhs.cpc = @pc.self
  | Br
      +flow = (++) [(@lhs.cpc, @pc.self), (@pc.self, getEntry (getId @t.self) @lhs.bbentrypci), (@pc.self, getEntry (getId @f.self) @lhs.bbentrypci)]
      lhs.cpc = @pc.self
      
{
getId :: Value -> String
getId (Id i t) = case i of 
                   Global s -> s
                   Local  s -> s 
getId _ = error "'getId'"

getEntry :: String -> Map.Map String Int -> Int
getEntry s m = fromMaybe (error $ "getEntry " ++ s ++ show m) $ Map.lookup s m
}

-- Entry & Exit points
attr Functions 
  syn bbentrypc use {`Map.union`} {Map.empty} :: {Map.Map String (Map.Map String Int)}

sem Functions
  | Entry 
      lhs.bbentrypc = Map.insert @key @val.bbentrypc @tl.bbentrypc

attr Function BasicBlocks BasicBlock Instructions Instruction
  syn entrypc :: {Int}
  syn exitpcs use {++} {[]} :: {[Int]}
  syn bbentrypc use {`Map.union`} {Map.empty} :: {Map.Map String Int}

sem Function
  | FunctionDecl
      lhs.entrypc = error "'entrypc' of a FunctionDecl"
      lhs.exitpcs = error "'exitpcs' of a FunctionDecl"
  | FunctionDef
      lhs.entrypc   = @body.entrypc
      lhs.exitpcs   = @body.exitpcs
      lhs.bbentrypc = @body.bbentrypc

sem BasicBlocks
  | Nil
      lhs.entrypc = error "'entrypc' of an empty bb list"
  | Cons
      lhs.entrypc = @hd.entrypc

sem BasicBlock
  | BasicBlock
       +bbentrypc = Map.insert @label.self @instrs.entrypc
      lhs.entrypc = @instrs.entrypc
         .exitpcs = @instrs.exitpcs

sem Instructions
  | Nil
     lhs.entrypc = error "'entrypc' of an empty i list"
  | Cons
     lhs.entrypc = @hd.entrypc

sem Instruction
  | Ret Alloca Load Store ICmp FCmp UBr Br Call Unreachable Trunc ZExt SExt FPToUI FPToSI UIToFP SIToFP FPTrunc FPExt PtrToInt IntToPtr BitCast GetElementPtr Add FAdd Sub FSub Mul FMul UDiv SDiv FDiv URem SRem FRem Shl LShr AShr And Or Xor PHI Select ExtractValue AtomicRMW CreateThread Switch
     lhs.entrypc = @pc.self

sem Instruction
  | Ret
      +exitpcs = (++) [@pc.self]
{
type Flow = [(Int,Int)]

flowfs :: Functions -> Flow
flowfs fs = let i = bbentrypc_Syn_Functions$ wrap_Functions (sem_Functions fs) $ Inh_Functions { bbentrypci_Inh_Functions = Map.empty }
            in flow_Syn_Functions $ wrap_Functions (sem_Functions fs) $ Inh_Functions { bbentrypci_Inh_Functions = i }
}
