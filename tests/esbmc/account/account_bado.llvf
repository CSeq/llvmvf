; ModuleID ='account_bado.bc'
target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%"struct.__pthread_internal_list" 2 {%"struct.__pthread_internal_list" 2 {}*, %"struct.__pthread_internal_list" 2 {}*}
%"struct.__pthread_mutex_s" 7 {i32, i32, i32, i32, i32, i32, %"struct.__pthread_internal_list" 2 {}}
%"union.pthread_attr_t" 2 {i64, [48 x i8]}
%"union.pthread_mutex_t" 1 {%"struct.__pthread_mutex_s" 7 {}}
%"union.pthread_mutexattr_t" 1 {i32}

@deposit_done = external  constant , i32 0, align 4
@withdraw_done = external  constant , i32 0, align 4
@m = common  constant , %"union.pthread_mutex_t" 1 {} zeroinitializer, align 8
@balance = common  constant , i32 0, align 4
@y = common  constant , i32 0, align 4
@z = common  constant , i32 0, align 4
@x = common  constant , i32 0, align 4
@.str = private unnamed_addr constant , [23 x i8] c"balance == (x - y) - z", align 1
@.str1 = private unnamed_addr constant , [14 x i8] c"account_bad.c", align 1
@__PRETTY_FUNCTION__.check_result = private unnamed_addr constant , [27 x i8] c"void *check_result(void *)", align 1

declare external void @__assert_fail(i8*, i8*, i32, i8*)
define external i8* @check_result(i8* %arg){
; <label>:bb
%tmp = call i32 @pthread_mutex_lock(%"union.pthread_mutex_t" 1 {}* @m)
%tmp1 = load i32* @deposit_done, align 4
%tmp2 = icmp ne i32 %tmp1, i32 0
%tmp3 = load i32* @withdraw_done, align 4
%tmp4 = icmp ne i32 %tmp3, i32 0
%or.cond = and i1 i1 %tmp2, i1 %tmp4
br i1 %or.cond, label %bb5, label %bb14

; <label>:bb5
%tmp6 = load i32* @balance, align 4
%tmp7 = load i32* @x, align 4
%tmp8 = load i32* @y, align 4
%tmp9 = load i32* @z, align 4
i32 %tmp10 = sub i32 %tmp7, i32 %tmp8
i32 %tmp11 = sub i32 %tmp10, i32 %tmp9
%tmp12 = icmp eq i32 %tmp6, i32 %tmp11
br i1 %tmp12, label %bb14, label %bb13

; <label>:bb13
% = call void @__assert_fail(getelementptr([23 x i8]* @.str, i64 0, i64 0), getelementptr([14 x i8]* @.str1, i64 0, i64 0), i32 30, getelementptr([27 x i8]* @__PRETTY_FUNCTION__.check_result, i64 0, i64 0))
unreachable

; <label>:bb14
%tmp15 = call i32 @pthread_mutex_unlock(%"union.pthread_mutex_t" 1 {}* @m)
ret undef


}
define external i8* @deposit(i8* %arg){
; <label>:bb
%tmp = call i32 @pthread_mutex_lock(%"union.pthread_mutex_t" 1 {}* @m)
%tmp1 = load i32* @balance, align 4
%tmp2 = load i32* @y, align 4
i32 %tmp3 = add i32 %tmp2, i32 %tmp1
void store i32 %tmp3, i32* @balance, align 4
void store i32 1, i32* @deposit_done, align 4
%tmp4 = call i32 @pthread_mutex_unlock(%"union.pthread_mutex_t" 1 {}* @m)
ret undef


}
define external i32 @main(){
; <label>:bb
%t1 = alloca i64, align 8
%t2 = alloca i64, align 8
%t3 = alloca i64, align 8
%tmp = call i32 @pthread_mutex_init(%"union.pthread_mutex_t" 1 {}* @m, %"union.pthread_mutexattr_t" 1 {}* null)
%tmp1 = call i32 @nondet_int()
void store i32 %tmp1, i32* @x, align 4
%tmp2 = call i32 @nondet_int()
void store i32 %tmp2, i32* @y, align 4
%tmp3 = call i32 @nondet_int()
void store i32 %tmp3, i32* @z, align 4
%tmp4 = load i32* @x, align 4
void store i32 %tmp4, i32* @balance, align 4
%tmp5 = call i32 @pthread_create(i64* %t3, %"union.pthread_attr_t" 2 {}* null, (i8* -> i8*)* @check_result, i8* null)
%tmp6 = call i32 @pthread_create(i64* %t1, %"union.pthread_attr_t" 2 {}* null, (i8* -> i8*)* @deposit, i8* null)
%tmp7 = call i32 @pthread_create(i64* %t2, %"union.pthread_attr_t" 2 {}* null, (i8* -> i8*)* @withdraw, i8* null)
ret i32 0


}
declare external i32 @nondet_int()
declare external i32 @pthread_create(i64*, %"union.pthread_attr_t" 2 {}*, (i8* -> i8*)*, i8*)
declare external i32 @pthread_mutex_init(%"union.pthread_mutex_t" 1 {}*, %"union.pthread_mutexattr_t" 1 {}*)
declare external i32 @pthread_mutex_lock(%"union.pthread_mutex_t" 1 {}*)
declare external i32 @pthread_mutex_unlock(%"union.pthread_mutex_t" 1 {}*)
define external i8* @withdraw(i8* %arg){
; <label>:bb
%tmp = call i32 @pthread_mutex_lock(%"union.pthread_mutex_t" 1 {}* @m)
%tmp1 = load i32* @balance, align 4
%tmp2 = load i32* @z, align 4
i32 %tmp3 = sub i32 %tmp1, i32 %tmp2
void store i32 %tmp3, i32* @balance, align 4
void store i32 1, i32* @withdraw_done, align 4
%tmp4 = call i32 @pthread_mutex_unlock(%"union.pthread_mutex_t" 1 {}* @m)
ret undef


}
