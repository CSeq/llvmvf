; ModuleID ='account_bado.bc'
target datalayout = "e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:32:64-S128"
target triple = "x86_64-unknown-linux-gnu"

%"struct.__pthread_internal_list" 2 {%"struct.__pthread_internal_list" 2 {}*, %"struct.__pthread_internal_list" 2 {}*}
%"struct.__pthread_mutex_s" 7 {i32, i32, i32, i32, i32, i32, %"struct.__pthread_internal_list" 2 {}}
%"union.pthread_attr_t" 2 {i64, [48 x i8]}
%"union.pthread_mutex_t" 1 {%"struct.__pthread_mutex_s" 7 {}}
%"union.pthread_mutexattr_t" 1 {i32}

@deposit_done = external  constant , i8 0, align 1
@withdraw_done = external  constant , i8 0, align 1
@m = common  constant , %"union.pthread_mutex_t" 1 {} zeroinitializer, align 8
@balance = common  constant , i32 0, align 4
@y = common  constant , i32 0, align 4
@z = common  constant , i32 0, align 4
@x = common  constant , i32 0, align 4

define external i8* @deposit(i8* %arg){
; <label>:bb
call i32 @pthread_mutex_lock(%"union.pthread_mutex_t" 1 {}* @m)
%tmp1 = load i32* @balance, align 4
%tmp2 = load i32* @y, align 4
i32 %tmp3 = add i32 %tmp2, i32 %tmp1
void store i32 %tmp3, i32* @balance, align 4
void store i8 1, i8* @deposit_done, align 1
call i32 @pthread_mutex_unlock(%"union.pthread_mutex_t" 1 {}* @m)
ret undef


}
declare external i32 @pthread_mutex_lock(%"union.pthread_mutex_t" 1 {}*)
declare external i32 @pthread_mutex_unlock(%"union.pthread_mutex_t" 1 {}*)
define external i8* @withdraw(i8* %arg){
; <label>:bb
call i32 @pthread_mutex_lock(%"union.pthread_mutex_t" 1 {}* @m)
%tmp1 = load i32* @balance, align 4
%tmp2 = load i32* @z, align 4
i32 %tmp3 = sub i32 %tmp1, i32 %tmp2
void store i32 %tmp3, i32* @balance, align 4
void store i8 1, i8* @withdraw_done, align 1
call i32 @pthread_mutex_unlock(%"union.pthread_mutex_t" 1 {}* @m)
ret undef


}
define external i8* @check_result(i8* %arg){
; <label>:bb
call i32 @pthread_mutex_lock(%"union.pthread_mutex_t" 1 {}* @m)
%tmp1 = load i8* @deposit_done, align 1
%tmp2 = icmp eq i8 %tmp1, i8 0
%tmp3 = load i8* @withdraw_done, align 1
%tmp4 = icmp eq i8 %tmp3, i8 0
%or.cond = or i1 i1 %tmp2, i1 %tmp4
br i1 %or.cond, label %bb15, label %bb5

; <label>:bb5
%tmp6 = load i32* @balance, align 4
%tmp7 = load i32* @x, align 4
%tmp8 = load i32* @y, align 4
%tmp9 = load i32* @z, align 4
i32 %tmp10 = sub i32 %tmp7, i32 %tmp8
i32 %tmp11 = sub i32 %tmp10, i32 %tmp9
%tmp12 = icmp eq i32 %tmp6, i32 %tmp11
%tmp13 = zext i1 %tmp12 to i32
call i32 @assert(i32 %tmp13)
br label %bb15

; <label>:bb15
call i32 @pthread_mutex_unlock(%"union.pthread_mutex_t" 1 {}* @m)
ret undef


}
declare external i32 @assert()
define external i32 @main(){
; <label>:bb
%t1 = alloca i64, align 8
%t2 = alloca i64, align 8
%t3 = alloca i64, align 8
call i32 @pthread_mutex_init(%"union.pthread_mutex_t" 1 {}* @m, %"union.pthread_mutexattr_t" 1 {}* null)
call i32 @nondet_int()
void store i32 %tmp1, i32* @x, align 4
call i32 @nondet_int()
void store i32 %tmp2, i32* @y, align 4
call i32 @nondet_int()
void store i32 %tmp3, i32* @z, align 4
%tmp4 = load i32* @x, align 4
void store i32 %tmp4, i32* @balance, align 4
call i32 @pthread_create(i64* %t3, %"union.pthread_attr_t" 2 {}* null, (i8* -> i8*)* @check_result, i8* null)
call i32 @pthread_create(i64* %t1, %"union.pthread_attr_t" 2 {}* null, (i8* -> i8*)* @deposit, i8* null)
call i32 @pthread_create(i64* %t2, %"union.pthread_attr_t" 2 {}* null, (i8* -> i8*)* @withdraw, i8* null)
ret i32 0


}
declare external i32 @pthread_mutex_init(%"union.pthread_mutex_t" 1 {}*, %"union.pthread_mutexattr_t" 1 {}*)
declare external i32 @nondet_int()
declare external i32 @pthread_create(i64*, %"union.pthread_attr_t" 2 {}*, (i8* -> i8*)*, i8*)

