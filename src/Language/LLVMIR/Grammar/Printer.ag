{
-------------------------------------------------------------------------------
-- Module    :  Language.LLVMIR.Printer
-- Copyright :  (c) 2012 Marcelo Sousa
-------------------------------------------------------------------------------
}

module {Language.LLVMIR.Printer}{}{}

imports 
{
import UU.PPrint as P
}

attr Parameters Types Values PValues PValue
  syn pp :: {Doc}

sem Parameters Types Values PValues
  | Nil  lhs.pp = P.empty
  | Cons lhs.pp = if (length @tl.self == 0)
                  then @hd.pp
                  else @hd.pp <> char ',' <+> @tl.pp

sem PValue
  | Tuple lhs.pp = char '[' <+> @x1.pp <> char ',' <+> @x2.pp <+> char ']'

attr Module Identifier TargetData DataLayout Functions Globals Global Linkage Align MValue Value Type TyFloatPoint Function Aliases Alias Parameter BasicBlocks BasicBlock Instructions Instruction IntPredicate RealPredicate NamedTypes Constant GlobalValue ConstantDataSequential ConstantExpr RetInst
  syn pp use {<$>} {P.empty} :: {Doc}

attr Target 
  syn pp :: {Doc}

sem Identifier
  | Global lhs.pp = char '@' <> text @name.self
  | Local  lhs.pp = char '%' <> text @name.self 

sem DataLayout
  | DataLayout
     lhs.pp = text "target datalayout =" <+> dquotes (Prelude.foldr1 (\x y -> x <> char '-' <> y) (Prelude.map text @s.self))

sem TargetData
  | TargetData
      lhs.pp = text "target triple =" <+> dquotes (text @s)

sem Target
  | MacOs lhs.pp = text "MacOs"
  | Linux lhs.pp = text "Linux"

sem Module
  | Module lhs.pp = text ("; ModuleID ='" ++ @id ++ "'") <$> @layout.pp <$> @target.pp <$> @nmdtys.pp <$> @gvars.pp <$> @funs.pp 

sem Global
  | GlobalVar lhs.pp = text "@" <> text @name.self <+> text "=" <+>  @linkage.pp <+> ppKeyword @isUaddr "unnamed_addr" <+> ppKeyword @isConst "constant" <+> text "," <+> @ival.pp <> text "," <+> @align.pp 

sem Function
  | FunctionDef  lhs.pp = text "define"  <+> @linkage.pp <+> @retty.pp <+> char '@' <> text @name.self <> parens @params.pp <> char '{' <$> @body.pp <$> char '}'
  | FunctionDecl lhs.pp = text "declare" <+> @linkage.pp <+> @retty.pp <+> char '@' <> text @name.self <> parens @params.pp

sem Parameter
  | Parameter lhs.pp = @ty.pp <> ppPName @var.self

sem BasicBlock
  | BasicBlock lhs.pp = text "; <label>:" <> text @label.self <$> @instrs.pp

sem RetInst
  | ValueRet lhs.pp = @v.pp
  | VoidRet  lhs.pp = text "void"

sem Instruction
  | Ret    lhs.pp = text "ret" <+> @r.pp 
  | Alloca lhs.pp = @id.pp <+> char '=' <+> text "alloca" <+> @ty.pp <> char ',' <+> @align.pp
  | Load   lhs.pp = @id.pp <+> char '=' <+> text "load"   <+> @v.pp  <> char ',' <+> @align.pp
  | Store  lhs.pp = @ty.pp <+> text "store" <+> @v1.pp <> char ',' <+> @v2.pp <> char ',' <+> @align.pp
  | ICmp   lhs.pp = @id.pp <+> char '=' <+> text "icmp"   <+> @cond.pp <+> @op1.pp <> char ',' <+> @op2.pp
  | FCmp   lhs.pp = @id.pp <+> char '=' <+> text "icmp"   <+> @cond.pp <+> @op1.pp <> char ',' <+> @op2.pp
  | UBr    lhs.pp = text "br" <+> @d.pp
  | Br     lhs.pp = text "br" <+> @v.pp <> comma <+> @t.pp <> comma <+> @f.pp
  | Call   lhs.pp = text "call" <+> @ty.pp <+> @callee.pp <> char '(' <> @args.pp <> char ')'
  | Unreachable lhs.pp = text "unreachable"
  | Trunc    lhs.pp = pConvOp @id.pp "trunc"    @v.pp @ty.pp
  | ZExt     lhs.pp = pConvOp @id.pp "zext"     @v.pp @ty.pp
  | SExt     lhs.pp = pConvOp @id.pp "sext"     @v.pp @ty.pp
  | FPToUI   lhs.pp = pConvOp @id.pp "fptoui"   @v.pp @ty.pp
  | FPToSI   lhs.pp = pConvOp @id.pp "fptosi"   @v.pp @ty.pp
  | UIToFP   lhs.pp = pConvOp @id.pp "uitofp"   @v.pp @ty.pp
  | SIToFP   lhs.pp = pConvOp @id.pp "sitofp"   @v.pp @ty.pp
  | FPTrunc  lhs.pp = pConvOp @id.pp "fptrunc"  @v.pp @ty.pp
  | FPExt    lhs.pp = pConvOp @id.pp "fpext"    @v.pp @ty.pp
  | PtrToInt lhs.pp = pConvOp @id.pp "ptrtoint" @v.pp @ty.pp
  | IntToPtr lhs.pp = pConvOp @id.pp "inttoptr" @v.pp @ty.pp
  | BitCast  lhs.pp = pConvOp @id.pp "bitcast"  @v.pp @ty.pp
  | GetElementPtr lhs.pp = @id.pp <+> char '=' <+> text "getelementptr" <+> @struct.pp <> char ',' <+> @idxs.pp
  | Add  lhs.pp = pBinOp @ty.pp @id.pp "add"  @op1.pp @op2.pp
  | FAdd lhs.pp = pBinOp @ty.pp @id.pp "fadd" @op1.pp @op2.pp
  | Sub  lhs.pp = pBinOp @ty.pp @id.pp "sub"  @op1.pp @op2.pp
  | FSub lhs.pp = pBinOp @ty.pp @id.pp "fsub" @op1.pp @op2.pp
  | Mul  lhs.pp = pBinOp @ty.pp @id.pp "mul"  @op1.pp @op2.pp
  | FMul lhs.pp = pBinOp @ty.pp @id.pp "fmul" @op1.pp @op2.pp
  | UDiv lhs.pp = pBinOp @ty.pp @id.pp "udiv" @op1.pp @op2.pp
  | SDiv lhs.pp = pBinOp @ty.pp @id.pp "sdiv" @op1.pp @op2.pp
  | FDiv lhs.pp = pBinOp @ty.pp @id.pp "fdiv" @op1.pp @op2.pp
  | URem lhs.pp = pBinOp @ty.pp @id.pp "urem" @op1.pp @op2.pp
  | SRem lhs.pp = pBinOp @ty.pp @id.pp "srem" @op1.pp @op2.pp
  | FRem lhs.pp = pBinOp @ty.pp @id.pp "frem" @op1.pp @op2.pp
  | Shl  lhs.pp = pBitBinOp @ty.pp @id.pp "shl"  @op1.pp @op2.pp
  | LShr lhs.pp = pBitBinOp @ty.pp @id.pp "lshr" @op1.pp @op2.pp
  | AShr lhs.pp = pBitBinOp @ty.pp @id.pp "ashr" @op1.pp @op2.pp
  | And  lhs.pp = pBitBinOp @ty.pp @id.pp "and"  @op1.pp @op2.pp
  | Or   lhs.pp = pBitBinOp @ty.pp @id.pp "or"   @op1.pp @op2.pp
  | Xor  lhs.pp = pBitBinOp @ty.pp @id.pp "xor"  @op1.pp @op2.pp
  | PHI  lhs.pp = @id.pp <+> char '=' <+> text "phi" <+> @ty.pp <+> @vals.pp
  | Select lhs.pp = @id.pp <+> char '=' <+> @cond.pp <> char ',' <+> @valt.pp <> char ',' <+> @valf.pp

{
pConvOp :: Doc -> String -> Doc -> Doc -> Doc
pConvOp id c v ty = id <+> char '=' <+> text c <+> v <+> text "to" <+> ty

pBinOp :: Doc -> Doc -> String -> Doc -> Doc -> Doc
pBinOp ty id c op1 op2 = ty <+> id <+> char '=' <+> text c <+> op1 <> char ',' <+> op2

pBitBinOp :: Doc -> Doc -> String -> Doc -> Doc -> Doc
pBitBinOp ty id c op1 op2 = id <+> char '=' <+> text c <+> ty <+> op1 <> char ',' <+> op2

}
 
sem Alias
  | Alias lhs.pp = text "%" <> text @name.self

sem NamedTypes
  | Nil   lhs.pp = text ""
  | Entry lhs.pp = text "%" <> text @key <+> char '=' <+> @val.pp <$> @tl.pp

sem IntPredicate
  | IntEQ  lhs.pp = text "eq" 
  | IntNE  lhs.pp = text "ne" 
  | IntUGT lhs.pp = text "ugt" 
  | IntUGE lhs.pp = text "uge" 
  | IntULT lhs.pp = text "ult" 
  | IntULE lhs.pp = text "ule" 
  | IntSGT lhs.pp = text "sgt" 
  | IntSGE lhs.pp = text "sge" 
  | IntSLT lhs.pp = text "slt" 
  | IntSLE lhs.pp = text "sle" 

sem RealPredicate
  | LLVMRealPredicateFalse lhs.pp = text "false"
  | LLVMRealOEQ            lhs.pp = text "oeq"
  | LLVMRealOGT            lhs.pp = text "ogt"
  | LLVMRealOGE            lhs.pp = text "oge"
  | LLVMRealOLT            lhs.pp = text "olt"
  | LLVMRealOLE            lhs.pp = text "ole"
  | LLVMRealONE            lhs.pp = text "one"
  | LLVMRealORD            lhs.pp = text "ord"
  | LLVMRealUNO            lhs.pp = text "uno"
  | LLVMRealUEQ            lhs.pp = text "ueq"
  | LLVMRealUGT            lhs.pp = text "ugt"
  | LLVMRealUGE            lhs.pp = text "uge"
  | LLVMRealULT            lhs.pp = text "ult"
  | LLVMRealULE            lhs.pp = text "ule"
  | LLVMRealUNE            lhs.pp = text "une"
  | LLVMRealPredicateTrue  lhs.pp = text "true"

sem Linkage
  | ExternalLinkage            lhs.pp = text "external" 
  | AvailableExternallyLinkage lhs.pp = text "available_externally"
  | LinkOnceAnyLinkage         lhs.pp = text "linkonce" 
  | LinkOnceODRLinkage         lhs.pp = text "linkonce_odr" 
  | WeakAnyLinkage             lhs.pp = text "weak" 
  | WeakODRLinkage             lhs.pp = text "weak_odr" 
  | AppendingLinkage           lhs.pp = text "appending"
  | InternalLinkage            lhs.pp = text "internal" 
  | PrivateLinkage             lhs.pp = text "private" 
  | DLLImportLinkage           lhs.pp = text "dllimport" 
  | DLLExportLinkage           lhs.pp = text "dllexport"
  | ExternalWeakLinkage        lhs.pp = text "external"
  | GhostLinkage               lhs.pp = text "ghost" -- ^OBSOLETE
  | CommonLinkage              lhs.pp = text "common"
  | LinkerPrivateLinkage       lhs.pp = text "linker_private"
  | LinkerPrivateWeakLinkage   lhs.pp = text "linker_private_weak"
  | LinkerPrivateWeakDefAutoLinkage lhs.pp = text "linker_private_weak_def_auto" 

sem Align
  | Align lhs.pp = text "align" <+> text (show @n)

sem MValue
  | Nothing lhs.pp = P.empty
  | Just    lhs.pp = @just.pp

sem Value
  | Id       lhs.pp = @ty.pp <+> @v.pp
  | Constant lhs.pp = @c.pp

sem Constant
  | BlockAddr              lhs.pp = text "blockaddr" 
  | ConstantAggregateZero  lhs.pp = @ty.pp <+> text "zeroinitializer"
  | ConstantArray          lhs.pp = @ty.pp <+> brackets @vals.pp
  | ConstantDataSequential lhs.pp = @cds.pp 
  | ConstantExpr           lhs.pp = @expr.pp
  | ConstantFP             lhs.pp = text "TODO ConstantFP" -- @ty.pp <+> float @fpv
  | ConstantInt            lhs.pp = @ty.pp <+> int   @iv
  | ConstantPointerNull    lhs.pp = @ty.pp <+> text "null"
  | ConstantStruct         lhs.pp = @ty.pp <+> braces @vals.pp
  | ConstantVector         lhs.pp = text "ConstantVector"
  | GlobalValue            lhs.pp = @gv.pp
  | UndefValue             lhs.pp = text "undef"

--  | ArrayC lhs.pp = @ty.pp <+> text "c" <> dquotes (escaped @val)
--  | NullC  lhs.pp = @ty.pp 
--  | UndefC lhs.pp = text "undef"
--  | IntC   lhs.pp = @ty.pp <+> int @v
--  | Pointer lhs.pp = @ty.pp <+> text "getelementptr" <> char '('  <+> @v.pp <> char ',' <+> @args.pp <> char ')'

sem ConstantDataSequential
  | ConstantDataArray          lhs.pp = @ty.pp <+> text "c" <> dquotes (escaped @val)
  | ConstantDataVector         lhs.pp = @ty.pp <+> text "c" <> dquotes (escaped @val)
                                             
sem ConstantExpr                             
  | BinaryConstantExpr         lhs.pp = text "BinaryConstantExpr"
  | CompareConstantExpr        lhs.pp = text "CompareConstantExpr"
  | ExtractElementConstantExpr lhs.pp = text "ExtractElementConstantExpr"
  | ExtractValueConstantExpr   lhs.pp = text "ExtractValueConstantExpr"
  | GetElementPtrConstantExpr  lhs.pp = text "getelementptr" <> parens (@struct.pp <> char ',' <+> @idxs.pp) 
  | InsertElementConstantExpr  lhs.pp = text "InsertElementConstantExpr"
  | InsertValueConstantExpr    lhs.pp = text "InsertValueConstantExpr"
  | SelectConstantExpr         lhs.pp = text "SelectConstantExpr"
  | ShuffleVectorConstantExpr  lhs.pp = text "ShuffleVectorConstantExpr"
  | UnaryConstantExpr          lhs.pp = @ty.pp <+> text @name <+> @val.pp

sem GlobalValue
  | FunctionValue  lhs.pp = @ty.pp <+> @n.pp 
  | GlobalAlias    lhs.pp = @ty.pp <+> @n.pp 
  | GlobalVariable lhs.pp = @ty.pp <+> @n.pp 

sem Type
  | TyVoid       lhs.pp = text "void"
  | Tyx86MMX     lhs.pp = text "x86mmx" 
  | TyLabel      lhs.pp = text "label"
  | TyMetadata   lhs.pp = text "metadata" 
  | TyOpaque     lhs.pp = text "opaque"
  | TyInt        lhs.pp = char 'i' <> int @p 
  | TyFloatPoint lhs.pp = @p.pp
  | TyArray      lhs.pp = brackets $ int @numEl <+> char 'x' <+> @ty.pp
  | TyFunction   lhs.pp = parens $ @party.pp <+> text "->" <+> @retty.pp 
  | TyStruct     lhs.pp = char '%' <> dquotes (escaped @name) <+> int @numEl <+> braces @tys.pp
  | TyPointer    lhs.pp = @ty.pp <> char '*'
  | TyVector     lhs.pp = char '<' <> int @numEl <+> char 'x' <+> @ty.pp <> char '>'

sem TyFloatPoint
  | TyHalf     lhs.pp = text "half" -- ^ Compatible with i386?
  | TyFloat    lhs.pp = text "float"
  | TyDouble   lhs.pp = text "double"
  | TyFP128    lhs.pp = text "fp128"
  | Tyx86FP80  lhs.pp = text "x86_fp80"
  | TyPPCFP128 lhs.pp = text "ppc_fp128"

{
ppPName :: String -> Doc
ppPName s = if (take 2 s == "0x")
            then P.empty
            else space <> char '%' <> text s

escaped :: String -> Doc
escaped ('\n':xs) = text "\\0A\\00" <> escaped xs
escaped (c:xs)    = char c <> escaped xs
escaped []        = P.empty

ppKeyword :: Bool -> String -> Doc
ppKeyword True s = text s
ppKeyword _    _ = P.empty

class MPretty a where
  pretty' :: a -> Doc

--instance Pretty 

instance Pretty Module where
    pretty mdl = pp_Syn_Module $ wrap_Module (sem_Module mdl) $ Inh_Module {}
    
instance Pretty DataLayout where
    pretty d = pp_Syn_DataLayout $ wrap_DataLayout (sem_DataLayout d) $ Inh_DataLayout {}

}
