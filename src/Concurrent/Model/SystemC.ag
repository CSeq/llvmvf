optpragmas {
{-#LANGUAGE EmptyDataDecls, RecordWildCards #-}
}

{
-------------------------------------------------------------------------------
-- Module    :  Concurrent.Model.SystemC
-- Copyright :  (c) 2012 Marcelo Sousa
-------------------------------------------------------------------------------
}

module {Concurrent.Model.SystemC}{}{}

include "Base.ag"
include "Type.ag"

imports 
{
import qualified Data.Map as Map
import qualified Data.IntMap as IM
import Data.Maybe 

import Concurrent.Model
import Language.LLVMIR
import UU.PPrint

import Debug.Trace (trace)

import Util.Demangler
import System.IO.Unsafe
import Concurrent.SysCModel
}

attr Module 
  syn smdl :: {Model SystemC}

sem Module
  | Module lhs.smdl  = Model Map.empty [] @funs.scmain IM.empty Map.empty -- @nmdtys.self @gvars.self @funs.scmain (toIM @funs.smdl) @funs.decls
--           funs.mfun = @funs.self
--           funs.counter = 1

attr Functions
  syn scmain :: {Process}
  syn smdl use {++} {[]} :: {[Process]}

{
toIM :: [Process] -> IM.IntMap Process
toIM l = IM.fromList $ zip [0..length l] l
}
 
attr Functions Function
  syn decls use {`Map.union`} {Map.empty} :: {Map.Map String (Type,Parameters)}
  inh scfun     :: {Map.Map String Function}
  chn counter   :: {ThreadLabel}
  
attr Function BasicBlocks BasicBlock Instructions Instruction Value Identifier Constant ConstantFP Linkage CConv Visibility DefinitionTy Argument Align GCName FunAttr Attribute Section TargetData Target Parameter IntPredicate RealPredicate GlobalValue ConstantDataSequential ConstantExpr RetInst NamedTypes CompareConstantExpr BinOp AtomicOrdering Type Types Parameters TyFloatPoint Label Arguments Values Id IntTyValIdL IntTyValId PValues MIdentifier PValue Ints PC 
  syn annotated :: self 

sem Functions
  | Nil   lhs.scmain = error "No SC_Main Function"
  | Entry lhs.scmain = if @key == "sc_main"
                       then Process @key @val.annotated
                       else @tl.scmain
          lhs.smdl   = trace @key $ if @key == "Initiator::thread_process()" -- || @key == "M1::T2()"
                       then (Process @key @val.annotated):(@tl.smdl) 
                       else @tl.smdl

sem Function
  | FunctionDef  +decls = Map.union (Map.singleton @name.self (@retty.self, @params.self))
  | FunctionDecl +decls = Map.union (Map.singleton @name.self (@retty.self, @params.self))

sem Instruction
  | Call 
    lhs.annotated = case @callee.self of
                         "sc_core::wait(sc_core::sc_event const&, sc_core::sc_simcontext*)" -> WaitEvent @pc.self 0
                         "sc_core::sc_event::notify()" -> NotifyEvent @pc.self 0
                         "sc_core::wait(sc_core::sc_time const&, sc_core::sc_simcontext*)"  -> WaitTime  @pc.self (@args.self !! 0)
                         x                      -> Call         @pc.self @mres.self @ty.self @callee.self @args.self   

{
type ThreadLabel = Int

nextUnique :: Int -> (Int, Int)
nextUnique u = (u+1, u)

getIdName :: Identifier -> String
getIdName (Global n) = n
getIdName (Local  n) = n

buildProcess :: Int -> String -> Values -> Map.Map String Function -> (Bool, IM.IntMap Process)
buildProcess c "pthread_create" v m = case v !! 2 of
                                        Constant (GlobalValue (FunctionValue i _)) -> let vn = getIdName i
                                                                                          f  = fromMaybe (error "buildProcess 1") $ Map.lookup vn m
                                                                                          f' = annotated_Syn_Function $ wrap_Function (sem_Function f) $ Inh_Function {}
                                                                                      in (True, IM.singleton c $ Process vn f')
                                        _ -> error "buildProcess 2"  
buildProcess c _                _ _ = (False, IM.empty)
 
-- SystemC
data SystemC

-- Synchronous (Interleaved) Concurrent Models
-- At one given time, there only one atomic instruction
-- being executed. Scheduler specification is required.
instance SCModel SystemC where
  -- model :: Module -> Model SystemC
  model mdl = smdl_Syn_Module $ wrap_Module (sem_Module mdl) $ Inh_Module {}

instance Pretty SystemC

convertSysC :: SysModel -> [(Model SystemC, MVars)]
convertSysC (SysC l) = Prelude.map convertToModel l

convertToModel :: ScMod -> (Model SystemC, MVars)
convertToModel (ScMod i vars prcs) = let smdl = Model Map.empty [] emptyProcess (toProcesses prcs) Map.empty
                                     in (smdl, vars) 

toProcesses :: MProcs -> Processes
toProcesses (Procs p) = IM.map toProcess p 

toProcess :: ScProc -> Process
toProcess (ScMethod i f) = Process i f
toProcess (ScThread i f) = Process i f


}
