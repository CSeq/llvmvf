{
-------------------------------------------------------------------------------
-- Module    :  Concurrent.Model.Encoder.Model
-- Copyright :  (c) 2012 Marcelo Sousa
-------------------------------------------------------------------------------
}

module {Concurrent.Model.Encoder.Model}{}{}

include "Base.ag"
include "Type.ag"

imports 
{
import Language.SMTLib2.Base
import Language.SMTLib2.Builder

import Language.LLVMIR

import Data.Char
import Data.Maybe
import Data.List (find)

import Numeric
}

-- Global Variables 
attr Globals Global
  syn genc use {++} {[]} :: {[SExpression]}
  chn gs   :: {GlobalState}
 
sem Global
  | GlobalVar
     +genc    = (++) @loc.enc
     loc.enc  = [ declfun @loc.sym @ty.sort ] ++ @loc.ienc 
     loc.ienc = maybe [] (\v -> [eq (IdentExpr $ SymIdent $ @loc.sym) v ]) @ival.sexpr
     loc.sym  = SimpleSym @name.self
     lhs.gs   = updateGS @lhs.gs @name.self @ival.self

{
updateGS :: GlobalState -> Id -> MValue -> GlobalState
updateGS (m,mi,pc) i v = (m, Map.insert i (fromMaybe (Constant $ UndefValue) v) mi, pc)

type Transition = (PC, Bool, [SExpression], GlobalState -> GlobalState, PC)
type GlobalState = (Map.Map String (PC, Map.Map Id Value), Map.Map Id Value, PC)
}

-- Local Variables
attr Function BasicBlocks BasicBlock Instructions Instruction Identifier
  syn locals use {++} {[]} :: {[Id]}

attr Function BasicBlocks BasicBlock Instructions Instruction
  syn menc   use {++} {[]} :: {[SExpression]}
  syn ts     use {++} {[]} :: {[Transition]}
  inh flow :: {[(Int,Int)]}
--  inh tys  :: {NamedTypes}
--  inh vars :: {Globals}

sem Function
  | FunctionDecl lhs.menc = []
  | FunctionDef  lhs.menc = @body.menc
                    .ts   = @body.ts

sem BasicBlock 
  | BasicBlock lhs.menc = @instrs.menc
                  .ts   = @instrs.ts

sem Instruction
  | Alloca +menc = (++) @loc.smt
           +ts   = (++) [(@pc.self, True, @loc.smt, @loc.upst, @loc.npc)]
           loc.smt  = [ declfun @id.ssymbol @ty.sort ]
           loc.upst = \(mt, mv, _) -> (mt, mv, @loc.npc) 
           loc.npc  = nextpc @pc.self @lhs.flow
  | Store  +menc = (++) @loc.smt
           +ts   = (++) [(@pc.self, True, @loc.smt, @loc.upst, @loc.npc)]
           loc.npc = nextpc @pc.self @lhs.flow
           loc.upst = \(mt, mv, _) -> (mt, mv, @loc.npc) 
           loc.smt = [ eq (fromJust @v1.sexpr) (fromJust @v2.sexpr) ]
-- TODO
  | Call   +menc = (++) @loc.rid
           loc.rid = if getIdent @mres.self == ""
                     then []
                     else [ declfun @mres.ssymbol @ty.sort ]
           +ts   = (++) [(@pc.self, True, @loc.rid, @loc.upst, @loc.npc)]
           loc.npc = nextpc @pc.self @lhs.flow
           loc.upst = \(mt, mv, _) -> (mt, mv, @loc.npc) 
  | BitCast +menc = (++) @loc.enc
            loc.enc  = [ declfun @id.ssymbol @ty.sort ] ++ [ eq (IdentExpr $ SymIdent @id.ssymbol) @loc.bc ]
            loc.bc   = ExtractExpr [ IdentExpr $ IdxIdent (SimpleSym "extract") [(getISize @ty.self)-1, 0] , fromJust @v.sexpr ]
            +ts   = (++) [(@pc.self, True, @loc.enc, @loc.upst, @loc.npc)]
            loc.npc = nextpc @pc.self @lhs.flow
            loc.upst = \(mt, mv, _) -> (mt, mv, @loc.npc) 
{
nextpc :: Int -> [(Int,Int)] -> Int
nextpc i l = let ls = Prelude.filter (\(p,r) -> p == i && r /= -1) l
             in  snd $ head ls --  maybe (error "nextpc") snd $ find ((i==) . fst) l
 
eq :: SExpr -> SExpr -> SExpression
eq s1 s2 = assert $ FnAppExpr (SymIdent $ SimpleSym "=") [s1, s2]

getIdent :: Identifier -> String
getIdent (Local s) = s
getIdent (Global s) = s
}
-- Value S Expressions
attr MValue Value Constant ConstantDataSequential GlobalValue 
  syn sexpr :: {Maybe SExpr}

sem MValue
  | Nothing lhs.sexpr = Nothing
  | Just    lhs.sexpr = @just.sexpr
 
sem Value
  | Id lhs.sexpr = Just $ IdentExpr $ SymIdent @v.ssymbol
  | Constant lhs.sexpr = @c.sexpr

sem Constant
  | ConstantInt            lhs.sexpr = Just $ IdentExpr $ IdxIdent (bv @iv) [getISize @ty.self] 
  | ConstantDataSequential lhs.sexpr = @cds.sexpr 
  | GlobalValue            lhs.sexpr = @gv.sexpr
  | ConstantAggregateZero  lhs.sexpr = Nothing
 
sem GlobalValue
  | FunctionValue  lhs.sexpr = Just $ IdentExpr $ SymIdent @n.ssymbol 
  | GlobalAlias    lhs.sexpr = Just $ IdentExpr $ SymIdent @n.ssymbol 
  | GlobalVariable lhs.sexpr = Just $ IdentExpr $ SymIdent @n.ssymbol 

sem ConstantDataSequential
  | ConstantDataArray  lhs.sexpr = Nothing
  | ConstantDataVector lhs.sexpr = Nothing

{
bv :: Int -> SSymbol
bv n = SimpleSym $ "bv" ++ show n

getISize :: Type -> Int
getISize (TyInt p)     = p
getISize (TyPointer p) = getISize p
getISize _ = 0
}
 
-- Sorts
attr Type
  syn sort :: {SSortExpr}

sem Type
  | TyInt    lhs.sort = BitVector @p
  | TyArray  lhs.sort = ArraySort (BitVector (getBSize @numEl)) @ty.sort  
  | TyVector lhs.sort = ArraySort (BitVector (getBSize @numEl)) @ty.sort  
  | TyVoid Tyx86MMX TyLabel TyMetadata TyOpaque TyFloatPoint TyFunction TyUndefined
             lhs.sort = error "enc type not supported"
  | TyStruct  lhs.sort = error "enc type struct not supported"
  | TyPointer lhs.sort = @ty.sort -- error "enc type pointer not supported"

{
getBSize :: Int -> Int
getBSize n =length $  showIntAtBase 2 intToDigit n ""
}

-- Identifiers
attr Identifier
  syn ssymbol :: {SSymbol}

sem Identifier
  | Local Global
     lhs.ssymbol = SimpleSym @name.self
  | Local
     +locals = (++) [@name.self]
