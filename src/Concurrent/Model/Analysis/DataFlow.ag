{
-------------------------------------------------------------------------------
-- Module    :  Concurrent.Model.Analysis.DataFlow
-- Copyright :  (c) 2012 Marcelo Sousa
-------------------------------------------------------------------------------
}

module {Concurrent.Model.Analysis.DataFlow}{}{}

include "Base.ag"
include "Type.ag"

imports{
import qualified Data.Map as Map
import qualified Data.IntMap as IM
import Data.Maybe 

import Debug.Trace

import Language.LLVMIR
}

-- Simple Data Flow Information
attr Functions
  syn dflow :: {Map.Map String (Map.Map Identifier Type)} 

attr Function BasicBlocks BasicBlock Instructions Instruction Value RetInst 
  syn dflow use {`Map.union`} {Map.empty} :: {Map.Map Identifier Type}

sem Functions
  | Nil
      lhs.dflow = Map.empty
  | Entry
      lhs.dflow = Map.insert @key @val.dflow @tl.dflow 

sem Function
  | FunctionDef
      lhs.dflow = @body.dflow
 
sem BasicBlock
  | BasicBlock
      lhs.dflow = @instrs.dflow

sem RetInst
  | ValueRet 
      +dflow = Map.union @loc.d
      loc.d  = case @v.self of
                 Constant c -> Map.empty
                 Id vi ty    -> Map.singleton vi ty 
  | VoidRet
      lhs.dflow = Map.empty

sem Instruction
  | Ret
      lhs.dflow = @r.dflow
  | Br  
      lhs.dflow = @v.dflow
  | Unreachable Switch UBr AtomicRMW
      lhs.dflow = Map.empty
  | Add FAdd Sub FSub Mul FMul UDiv SDiv FDiv URem SRem FRem Shl LShr AShr And Or Xor ICmp FCmp
      lhs.dflow = Map.insert @id.self @ty.self $ Map.union @op1.dflow @op2.dflow
  | Alloca GetElementPtr Trunc ZExt SExt FPToUI FPToSI UIToFP SIToFP FPTrunc FPExt PtrToInt IntToPtr BitCast PHI
      lhs.dflow = Map.singleton @id.self @ty.self
  | Store
      lhs.dflow = Map.union @v1.dflow @v2.dflow
  | Load
      lhs.dflow = Map.singleton @id.self @v.wtype
  | Call 
      lhs.dflow = if (getId @mres.self) /= ""
                  then Map.singleton @mres.self @ty.self
                  else Map.empty
  | Select
      lhs.dflow = Map.singleton @id.self @cond.wtype
  | ExtractValue
      lhs.dflow = Map.singleton @id.self @aggr.wtype

{
getId :: Identifier -> Id
getId (Local s) = s
getId (Global s) = s
}

attr Value Constant ConstantDataSequential GlobalValue
  syn wtype :: {Type}

sem Value
  | Id       +dflow = Map.insert @v.self @ty.self 
          lhs.wtype = @ty.self
  | Constant lhs.dflow = Map.empty
                .wtype = @c.wtype

sem Constant
  | BlockAddr              lhs.wtype = TyUndefined 
  | ConstantAggregateZero  lhs.wtype = @ty.self
  | ConstantArray          lhs.wtype = @ty.self 
  | ConstantDataSequential lhs.wtype = @cds.wtype 
  | ConstantExpr           lhs.wtype = TyUndefined 
  | ConstantFP             lhs.wtype = TyUndefined
  | ConstantInt            lhs.wtype = TyInt @iv
  | ConstantPointerNull    lhs.wtype = @ty.self
  | ConstantStruct         lhs.wtype = @ty 
  | ConstantVector         lhs.wtype = TyUndefined
  | GlobalValue            lhs.wtype = @gv.wtype 
  | UndefValue             lhs.wtype = TyUndefined

sem ConstantDataSequential
  | ConstantDataArray  lhs.wtype = @ty.self 
  | ConstantDataVector lhs.wtype = @ty.self 

sem GlobalValue
  | FunctionValue  lhs.wtype = @ty.self 
  | GlobalAlias    lhs.wtype = @ty.self 
  | GlobalVariable lhs.wtype = @ty.self 

{
type DataFlow = Map.Map String (Map.Map Identifier Type)

dflowfs :: Functions -> DataFlow
dflowfs fs = dflow_Syn_Functions $ wrap_Functions (sem_Functions fs) $ Inh_Functions { }
}
