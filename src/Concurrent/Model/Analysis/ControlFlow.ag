{
-------------------------------------------------------------------------------
-- Module    :  Concurrent.Model.Analysis.ControlFlow
-- Copyright :  (c) 2012 Marcelo Sousa
-------------------------------------------------------------------------------
}

module {Concurrent.Model.Analysis.ControlFlow}{}{}

include "Base.ag"

imports{
import qualified Data.Map as Map
import qualified Data.IntMap as IM
import Data.Maybe 

import Debug.Trace

import Language.LLVMIR
}

{
-- TODO: Join back the threads to the function that called them
type CF = [(Int,Int)]

{-
data CS = ReadS
        | WriteS
        | Wait
-}

data ControlFlow = ControlFlow { cte :: Map.Map Identifier Int    -- ^ Entry Point for Ti
                               , cfg :: Map.Map Identifier CF     -- ^ Control Flow for Ti
                             --  , cgv  :: Map.Map Id ([Int], [Int]) --  ^ Data Flow Points where we use global variables - The pair ([Int],[Int]) is for Read and Write
                               }
}

-- Concurrent Control Flow Graph
attr Functions
  inh mainfnName :: {String}
  inh bbentrypci :: {Map.Map String (Map.Map Identifier Int)}
--  syn threadIds use {++} {[]} :: {[Identifier]}
  syn cflow     use {++} {[]} :: {CF}
  syn cte       use {`Map.union`} {Map.empty} :: {Map.Map Identifier Int}
  syn cfg       use {`Map.union`} {Map.empty} :: {Map.Map Identifier CF}

sem Module
  | Module
      funs.bbentrypci = error "Error ControlFlow.ag (1)"
      funs.mainfnName = error "Error ControlFlow.ag (2)"

sem Functions
  | Entry
      lhs.cflow = @loc.cflow ++ @val.cflow ++ @tl.cflow
      val.cpc  = @val.entrypc
      val.bbentrypci = fromMaybe (error "lookup") (Map.lookup @key @lhs.bbentrypci)
      lhs.cte = Map.insert (Global @key) @val.entrypc @tl.cte
      lhs.cfg = Map.insert (Global @key) (@loc.cflow ++ @val.cflow) @tl.cfg
      loc.cflow = if @key /= @lhs.mainfnName
                  then [(-1,@val.entrypc)]
                  else []


attr Function BasicBlocks BasicBlock Instructions Instruction
  inh mainfnName :: {String}
  inh bbentrypci :: {Map.Map Identifier Int}
  chn cpc :: {Int}
--  syn threadIds use {++} {[]} :: {[Identifier]}
  syn cflow     use {++} {[]} :: {CF}

sem Function
  | FunctionDef
      lhs.cflow = @body.cflow
  --    lhs.threadIds = @body.threadIds
 
sem BasicBlock
  | BasicBlock
      lhs.cflow = tail @instrs.cflow
  --    lhs.threadIds = @instrs.threadIds

sem Instruction
  | Ret Alloca Load Store ICmp FCmp Call Unreachable Trunc ZExt SExt FPToUI FPToSI UIToFP SIToFP FPTrunc FPExt PtrToInt IntToPtr BitCast GetElementPtr Add FAdd Sub FSub Mul FMul UDiv SDiv FDiv URem SRem FRem Shl LShr AShr And Or Xor PHI Select ExtractValue AtomicRMW MutexInit MutexLock MutexUnlock
      +cflow = (++) [(@lhs.cpc, @pc.self)]
      lhs.cpc = @pc.self
  | CreateThread 
      +cflow = (++) [(@lhs.cpc, @pc.self), (@pc.self, -1)]
  --    lhs.threadIds = [getIdentifier (@args.self!!0)] 
      lhs.cpc = @pc.self
  | UBr 
      +cflow = (++) [(@lhs.cpc, @pc.self), (@pc.self, getEntry (getIdentifier' @d.self) @lhs.bbentrypci)]
      lhs.cpc = @pc.self
  | Br
      +cflow = (++) [(@lhs.cpc, @pc.self), (@pc.self, getEntry (getIdentifier' @t.self) @lhs.bbentrypci), (@pc.self, getEntry (getIdentifier' @f.self) @lhs.bbentrypci)]
      lhs.cpc = @pc.self
      
{
getEntry :: Identifier -> Map.Map Identifier Int -> Int
getEntry s m = fromMaybe (error $ "getEntry " ++ show s ++ show m) $ Map.lookup s m

getId :: Identifier -> Id
getId (Global i) = i
getId (Local  i) = i

getIdentifier :: Value -> Maybe Identifier
getIdentifier (Id i _) = Just i
getIdentifier _        = Nothing

getIdValue :: Value -> Maybe Id
getIdValue (Id i _) = Just $ getId i
getIdValue _        = Nothing

getIdentifier' :: Value -> Identifier
getIdentifier' = fromMaybe (error "Value is not Identifier") . getIdentifier

getIdValue' :: Value -> Id
getIdValue' = getId . getIdentifier'
}

-- Entry & Exit points
attr Functions 
  syn bbentrypc use {`Map.union`} {Map.empty} :: {Map.Map String (Map.Map Identifier Int)}

sem Functions
  | Entry 
      lhs.bbentrypc = if @key == "sc_main" 
                      then @tl.bbentrypc
                      else Map.insert @key @val.bbentrypc @tl.bbentrypc

attr Function BasicBlocks BasicBlock Instructions Instruction
  syn entrypc :: {Int}
  syn exitpcs use {++} {[]} :: {[Int]}
  syn bbentrypc use {`Map.union`} {Map.empty} :: {Map.Map Identifier Int}

sem Function
  | FunctionDecl
      lhs.entrypc = error "'entrypc' of a FunctionDecl"
      lhs.exitpcs = error "'exitpcs' of a FunctionDecl"
  | FunctionDef
      lhs.entrypc   = @body.entrypc
      lhs.exitpcs   = @body.exitpcs
      lhs.bbentrypc = @body.bbentrypc

sem BasicBlocks
  | Nil
      lhs.entrypc = -1 -- error "'entrypc' of an empty bb list"
  | Cons
      lhs.entrypc = @hd.entrypc

sem BasicBlock
  | BasicBlock
       +bbentrypc = Map.insert @label.self @instrs.entrypc
      lhs.entrypc = @instrs.entrypc
         .exitpcs = @instrs.exitpcs

sem Instructions
  | Nil
     lhs.entrypc = error "'entrypc' of an empty i list"
  | Cons
     lhs.entrypc = @hd.entrypc

sem Instruction
  | Ret Alloca Load Store ICmp FCmp UBr Br Call Unreachable Trunc ZExt SExt FPToUI FPToSI UIToFP SIToFP FPTrunc FPExt PtrToInt IntToPtr BitCast GetElementPtr Add FAdd Sub FSub Mul FMul UDiv SDiv FDiv URem SRem FRem Shl LShr AShr And Or Xor PHI Select ExtractValue InsertValue Cmpxchg AtomicRMW CreateThread Switch MutexInit MutexLock MutexUnlock NotifyEvent WaitEvent WaitTime
     lhs.entrypc = @pc.self

sem Instruction
  | Ret
      +exitpcs = (++) [@pc.self]
{
cflowfs :: Functions -> ControlFlow
cflowfs fs = let i = bbentrypc_Syn_Functions$ wrap_Functions (sem_Functions fs) $ Inh_Functions { bbentrypci_Inh_Functions = Map.empty, mainfnName_Inh_Functions = "main" }
                 c = wrap_Functions (sem_Functions fs) $ Inh_Functions { bbentrypci_Inh_Functions = i, mainfnName_Inh_Functions = "main" }
             in ControlFlow (cte_Syn_Functions c) (cfg_Syn_Functions c) 
}
