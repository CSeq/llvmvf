{
-------------------------------------------------------------------------------
-- Module    :  Concurrent.Model.ESEncoder.Value
-- Copyright :  (c) 2012 Marcelo Sousa
-------------------------------------------------------------------------------
}

module {Concurrent.Model.ESEncoder.Value}{}{}

-- Value S Expressions
attr MValue 
  chn mts    :: {Map.Map Type SSort} 
  syn sexprs :: {SExpressions}
  syn sexpr  :: {ISExpr}
  inh tn     :: {String}             -- Thread Name
  inh val    :: {Valuation}
    
sem MValue
  | Nothing 
      lhs.sexpr  = ISEmpty 
         .sexprs = []
  | Just    
      lhs.sexpr  = @just.sexpr
         .sexprs = @just.sexprs

attr Values
  chn mts    :: {Map.Map Type SSort}
  inh val    :: {Valuation}
  inh tn     :: {String}             -- Thread Name
  syn sexprs use {++} {[]} :: {SExpressions}
  syn sexpr  use {++} {[]} :: {[ISExpr]}
  syn vtype  use {++} {[]} :: {[Type]}

sem Values
  | Nil
      lhs.mts = @lhs.mts
  | Cons
      hd.mts  = @lhs.mts
      tl.mts  = @hd.mts
      lhs.mts = @tl.mts
      lhs.sexpr = @hd.sexpr:(@tl.sexpr)
      lhs.vtype = @hd.vtype:(@tl.vtype)

attr Value Constant ConstantFP ConstantDataSequential ConstantExpr GlobalValue 
  chn mts    :: {Map.Map Type SSort}
  syn sexprs :: {SExpressions}
  syn sexpr  :: {ISExpr}
  inh tn     :: {String}             -- Thread Name
  inh val    :: {Valuation}
  syn vtype  :: {Type}

sem Value
  | Id 
      ty.mts     = @lhs.mts
      ty.mn      = Nothing
      v.tn       = @lhs.tn
      lhs.sexpr  = case ivalueId @lhs.val @v.ident of
                        Nothing -> @v.sexpr
                        Just i  -> ISExpr $ IdentExpr $ SymIdent $ SimpleSym $ @lhs.tn ++ i
         .sexprs = @ty.sexprs
         .mts    = @ty.mts
         .vtype  = @ty.self

  | Constant 
      lhs.sexpr  = @c.sexpr
         .sexprs = @c.sexprs
         .vtype     = @c.vtype

sem Constant
  | BlockAddr ConstantArray ConstantStruct ConstantVector ConstantPointerNull UndefValue
      lhs.sexpr  = verrormessage
         .sexprs = []
         .vtype     = verrormessage
  | ConstantAggregateZero
      lhs.sexpr  = ISEmpty 
         .sexprs = []
         .vtype     = verrormessage
      ty.mn = Nothing
  | ConstantDataSequential 
      lhs.sexpr  = @cds.sexpr
         .sexprs = @cds.sexprs
         .vtype  = @cds.vtype
  | ConstantExpr       
      lhs.sexpr  = @expr.sexpr
         .sexprs = @expr.sexprs
         .vtype  = @expr.vtype
  | ConstantFP          
      lhs.sexpr  = @fp.sexpr
         .sexprs = @fp.sexprs
         .vtype  = @fp.vtype
  | ConstantInt 
      lhs.sexpr  = ISExpr $ IdentExpr $ IdxIdent (bv @iv) [getISize @ty.self]
         .sexprs = [] --  ty :: Type
         .vtype  = @ty.self
  | GlobalValue          
      lhs.sexpr  = @gv.sexpr
         .sexprs = @gv.sexprs
         .ty     = @gv.ty

-- TODO
sem ConstantFP
  | ConstantFPFloat ConstantFPDouble
      lhs.sexpr  = verrormessage
         .sexprs = verrormessage
         .vtype  = verrormessage

sem GlobalValue
  | FunctionValue  GlobalAlias GlobalVariable 
      n.tn = @lhs.tn
      lhs.sexpr  = ISExpr $ IdentExpr $ SymIdent @n.ssymbol 
         .sexprs = []
         .vtype  = @ty.self
  -- n :: Identifier ty :: Type

sem ConstantDataSequential
  | ConstantDataArray  -- ty :: Type val :: String
      lhs.sexpr  = ISEmpty
         .sexprs = []
         .vtype  = verrormessage
  | ConstantDataVector -- ty :: Type val :: String
      lhs.sexpr  = error "data vector"
         .sexprs = []
         .vtype  = verrormessage

-- TODO
sem ConstantExpr
  | GetElementPtrConstantExpr
      struct.mts = @lhs.mts
      idxs.mts   = @struct.mts
      lhs.mts    = @idxs.mts
      struct.tn  = @lhs.tn
      idxs.tn    = @lhs.tn
      lhs.vtype  = @struct.vtype
      loc.idxn   = let x = getIdxN @struct.vtype
                   in trace (show x ++ " " ++ show @struct.vtype) $ x
      lhs.sexprs = @struct.sexprs ++ @idxs.sexprs
      lhs.sexpr  = foldr (\(n, s1) s2 -> sFn "select" s2 $ changeN s1 n) @struct.sexpr $ zip @loc.idxn $ init' @idxs.sexpr 
      
  | BinaryConstantExpr CompareConstantExpr ExtractElementConstantExpr ExtractValueConstantExpr InsertElementConstantExpr InsertValueConstantExpr SelectConstantExpr ShuffleVectorConstantExpr UnaryConstantExpr
      lhs.sexpr  = verrormessage
         .sexprs = verrormessage
         .vtype  = verrormessage

-- TODO
sem CompareConstantExpr
  | ICmpExpr FCmpExpr 
      lhs.sexpr  = verrormessage
         .sexprs = verrormessage
         .vtype  = verrormessage

-- Parameter
attr Parameter
  chn mts    :: {Map.Map Type SSort}
  syn sexprs :: {SExpressions}
  syn sexpr  :: {ISExpr}
  inh tn     :: {String}             -- Thread Name

sem Parameter
  | Parameter 
      lhs.sexpr = ISExpr $ IdentExpr $ SymIdent @loc.sym
      loc.sym   = SimpleSym $ @lhs.tn ++ @var.self
      ty.mts = @lhs.mts
      ty.mn  = Nothing
      lhs.sexprs = [ declfun @loc.sym @ty.sort ] ++ @ty.sexprs
      lhs.mts    = @ty.mts
 
{
init' :: [a] -> [a]
init' [] = []
init' [x] = [x]
init' [x,y] = [x]
init' (x:y:ys) = x:(init' (y:ys))

verrormessage = error "value instance not supported"

bv :: Int -> SSymbol
bv n = SimpleSym $ "bv" ++ show n

changeN :: ISExpr -> Int -> ISExpr
changeN (ISExpr (IdentExpr (IdxIdent s _))) n = ISExpr $ IdentExpr $ IdxIdent s [n]
changeN _ _ = error "changeN"

getGValueId :: Value -> Maybe Id
getGValueId (Id (Global i) _) = Just i
getGValueId (Constant (GlobalValue (GlobalVariable (Global i) _))) = Just i
getGValueId _ = Nothing

getValueId :: Value -> Maybe Id
getValueId (Id (Global i) _) = Just i
getValueId (Id (Local  i) _) = Just i
getValueId (Constant (GlobalValue (GlobalVariable (Global i) _))) = Just i
getValueId _ = Nothing


encValue :: Value -> Map.Map Type SSort -> Valuation -> String -> (Map.Map Type SSort, SExpressions, ISExpr) 
encValue v mts val tn = let vw = wrap_Value (sem_Value v) $ Inh_Value {mts_Inh_Value = mts, tn_Inh_Value = tn, val_Inh_Value = val}
                        in (mts_Syn_Value vw, sexprs_Syn_Value vw, sexpr_Syn_Value vw)

encParameter :: Parameter -> Map.Map Type SSort -> String -> (Map.Map Type SSort, SExpressions, ISExpr)
encParameter p mts tn = let pw = wrap_Parameter (sem_Parameter p) $ Inh_Parameter {mts_Inh_Parameter = mts, tn_Inh_Parameter = tn}
                        in (mts_Syn_Parameter pw, sexprs_Syn_Parameter pw, sexpr_Syn_Parameter pw)


getValueType :: Value -> Type 
getValueType v = vtype_Syn_Value $ wrap_Value (sem_Value v) $ Inh_Value {mts_Inh_Value = undefined, tn_Inh_Value = undefined, val_Inh_Value = undefined}

getFnValueName :: Value -> Id
getFnValueName (Constant (GlobalValue (FunctionValue (Global n) _))) = n
getFnValueName _ = error "getFnValueName failed"
}

