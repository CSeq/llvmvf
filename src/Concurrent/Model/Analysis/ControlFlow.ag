{
-------------------------------------------------------------------------------
-- Module    :  Concurrent.Model.Analysis.ControlFlow
-- Copyright :  (c) 2012 Marcelo Sousa
-------------------------------------------------------------------------------
}

module {Concurrent.Model.Analysis.ControlFlow}{}{}

include "Base.ag"

imports{
import qualified Data.Map as Map
import qualified Data.IntMap as IM
import Data.Maybe 

import Debug.Trace

import Language.LLVMIR
}

{
type CF = [(Int,Int)]

{-
data CS = ReadS
        | WriteS
        | Wait
-}

data ControlFlow = ControlFlow { cte :: Map.Map String Int   -- ^ Entry Point for Ti
                               , cfg :: Map.Map String CF     -- ^ Control Flow for Ti
                             --  , cgv  :: Map.Map Id ([Int], [Int]) --  ^ Data Flow Points where we use global variables - The pair ([Int],[Int]) is for Read and Write
                               }
}

-- Concurrent Control Flow Graph
attr Function BasicBlocks BasicBlock Instructions Instruction
  chn cpc :: {Int}

attr Functions
  inh bbentrypci :: {Map.Map String (Map.Map String Int)}
  syn cflow use {++} {[]} :: {CF}
  syn cte   use {`Map.union`} {Map.empty} :: {Map.Map String Int}
  syn cfg   use {`Map.union`} {Map.empty} :: {Map.Map String CF}
 
attr Function BasicBlocks BasicBlock Instructions Instruction
  syn cflow use {++} {[]} :: {CF}
  inh bbentrypci :: {Map.Map String Int}

sem Functions
  | Entry
      lhs.cflow = @loc.cflow ++ @val.cflow ++ @tl.cflow
      val.cpc  = @val.entrypc
      val.bbentrypci = fromMaybe (error "lookup") (Map.lookup @key @lhs.bbentrypci)
      lhs.cte = Map.insert @key @val.entrypc @tl.cte
      lhs.cfg = Map.insert @key (@loc.cflow ++ @val.cflow) @tl.cfg
      loc.cflow = if @key /= "main"
                  then [(-1,@val.entrypc)]
                  else []
sem Function
  | FunctionDef
      lhs.cflow = @body.cflow
 
sem BasicBlock
  | BasicBlock
      lhs.cflow = tail @instrs.cflow

sem Instruction
  | Ret Alloca Load Store ICmp FCmp Call Unreachable Trunc ZExt SExt FPToUI FPToSI UIToFP SIToFP FPTrunc FPExt PtrToInt IntToPtr BitCast GetElementPtr Add FAdd Sub FSub Mul FMul UDiv SDiv FDiv URem SRem FRem Shl LShr AShr And Or Xor PHI Select ExtractValue AtomicRMW
      +cflow = (++) [(@lhs.cpc, @pc.self)]
      lhs.cpc = @pc.self
  | CreateThread 
      +cflow = (++) [(@lhs.cpc, @pc.self), (@pc.self, -1)] 
      lhs.cpc = @pc.self
  | UBr 
      +cflow = (++) [(@lhs.cpc, @pc.self), (@pc.self, getEntry (getId @d.self) @lhs.bbentrypci)]
      lhs.cpc = @pc.self
  | Br
      +cflow = (++) [(@lhs.cpc, @pc.self), (@pc.self, getEntry (getId @t.self) @lhs.bbentrypci), (@pc.self, getEntry (getId @f.self) @lhs.bbentrypci)]
      lhs.cpc = @pc.self
      
{
getId :: Value -> String
getId (Id i t) = case i of 
                   Global s -> s
                   Local  s -> s 
getId _ = error "'getId'"

getEntry :: String -> Map.Map String Int -> Int
getEntry s m = fromMaybe (error $ "getEntry " ++ s ++ show m) $ Map.lookup s m
}

-- Entry & Exit points
attr Functions 
  syn bbentrypc use {`Map.union`} {Map.empty} :: {Map.Map String (Map.Map String Int)}

sem Functions
  | Entry 
      lhs.bbentrypc = Map.insert @key @val.bbentrypc @tl.bbentrypc

attr Function BasicBlocks BasicBlock Instructions Instruction
  syn entrypc :: {Int}
  syn exitpcs use {++} {[]} :: {[Int]}
  syn bbentrypc use {`Map.union`} {Map.empty} :: {Map.Map String Int}

sem Function
  | FunctionDecl
      lhs.entrypc = error "'entrypc' of a FunctionDecl"
      lhs.exitpcs = error "'exitpcs' of a FunctionDecl"
  | FunctionDef
      lhs.entrypc   = @body.entrypc
      lhs.exitpcs   = @body.exitpcs
      lhs.bbentrypc = @body.bbentrypc

sem BasicBlocks
  | Nil
      lhs.entrypc = error "'entrypc' of an empty bb list"
  | Cons
      lhs.entrypc = @hd.entrypc

sem BasicBlock
  | BasicBlock
       +bbentrypc = Map.insert @label.self @instrs.entrypc
      lhs.entrypc = @instrs.entrypc
         .exitpcs = @instrs.exitpcs

sem Instructions
  | Nil
     lhs.entrypc = error "'entrypc' of an empty i list"
  | Cons
     lhs.entrypc = @hd.entrypc

sem Instruction
  | Ret Alloca Load Store ICmp FCmp UBr Br Call Unreachable Trunc ZExt SExt FPToUI FPToSI UIToFP SIToFP FPTrunc FPExt PtrToInt IntToPtr BitCast GetElementPtr Add FAdd Sub FSub Mul FMul UDiv SDiv FDiv URem SRem FRem Shl LShr AShr And Or Xor PHI Select ExtractValue AtomicRMW CreateThread Switch
     lhs.entrypc = @pc.self

sem Instruction
  | Ret
      +exitpcs = (++) [@pc.self]
{
cflowfs :: Functions -> ControlFlow
cflowfs fs = let i = bbentrypc_Syn_Functions$ wrap_Functions (sem_Functions fs) $ Inh_Functions { bbentrypci_Inh_Functions = Map.empty }
                 c = wrap_Functions (sem_Functions fs) $ Inh_Functions { bbentrypci_Inh_Functions = i }
             in ControlFlow (cte_Syn_Functions c) (cfg_Syn_Functions c) 
}
